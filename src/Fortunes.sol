// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Owned} from "solmate/auth/Owned.sol";
import {VRFConsumerBaseV2} from "./chainlink/VRFConsumerBaseV2.sol";
import {VRFCoordinatorV2Interface} from "./chainlink/VRFCoordinatorV2Interface.sol";
import {Owned} from "solmate/auth/Owned.sol";
import {IStakedAvax} from "./benqi/IStakedAvax.sol";

contract Fortunes is VRFConsumerBaseV2, Owned {
    /**

		8888888888               888                              d8b             8888888b.          888 888		   _______
		888                      888                              88P             888   Y88b         888 888		  /\ o o o\
		888                      888                              8P              888    888         888 888		 /o \ o o o\_______
		8888888  .d88b.  888d888 888888 888  888 88888b.   .d88b. "  .d8888b      888   d88P .d88b.  888 888		<    >------>   o /|
		888     d88""88b 888P"   888    888  888 888 "88b d8P  Y8b   88K          8888888P" d88""88b 888 888		 \ o/  o   /_____/o|
		888     888  888 888     888    888  888 888  888 88888888   "Y8888b.     888 T88b  888  888 888 888		  \/______/     |oo|
		888     Y88..88P 888     Y88b.  Y88b 888 888  888 Y8b.            X88     888  T88b Y88..88P 888 888		        |   o   |o/
		888      "Y88P"  888      "Y888  "Y88888 888  888  "Y8888     88888P'     888   T88b "Y88P"  888 888		        |_______|/

		Fortune's Roll is a game of chance where players deposit funds and roll a dice to increase their fortune.
		At the end of the game, players can redeem their fortunes for a share of the total yield generated by deposits throughout the game.

		# Contract Structure:

		## Methods

		### Deposits and withdrawals
		1. Deposit at any time ðŸ§ª
		2. Forfeit while game is running ðŸ§ª
		3. Redeem after end of game ðŸ§ª

		### User Game functions
		1. Roll For Add ðŸ§ª
		2. Roll For Multiply ðŸ§ª
		3. Roll For Seizure ðŸ§ª
		4. Close current Seizure ðŸ§ª

		### Chainlink VRF functions
		1. FulfillRandomness - generates a new dice roll for a user ðŸ§ª

		### Admin Game functions
		1. Set seizure ðŸ§ª

		### View/Helper functions
		1. Calculate Dice Rolls ðŸ§ª
		2. Calculate Rewards ðŸ§ª
		3. Calculate Seizure Rewards ðŸ§ª

		## Mapping & Variables

		### Bookkeeping
		1. Fortunes - a mapping of addresses to their fortunes. âœ…
		2. Deposits - a mapping of addresses to their deposits. âœ…
		3. Vault - fortunes lost by players accumulate here. âœ…

		### Parameters
		1. Dice roll generation rate - how often to generate a new dice roll. âœ…
		2. Addition multiplier - how much to multiply the dice roll by when adding. âœ…
		3. Multiplication multiplier - how much to multiply the dice roll by when multiplying. âœ…
	 */

    /* -------------------------------------------------------------------------- */
    /*                            Mappings & Variables                            */
    /* -------------------------------------------------------------------------- */

    uint8 private constant DICE_SIDES = 12;
    uint256 private constant PRECISION = 1e6;

    struct FortuneSeeker {
        uint256 fortune;
        uint256 deposit;
        uint256 diceRollsRemaining;
        uint256 lastDiceRollTimestamp;
    }

    struct Seizure {
        uint256 start;
        uint256 end;
        uint256 fee;
        uint256[DICE_SIDES] rewardShares; // denominated in PRECISION e.g 50% = 0.5 * PRECISION. Total should never exceed 1 * PRECISION
        uint256[DICE_SIDES] seizorTallies; // number of seekers who rolled each side
        uint256 rewardSharesTotal;
        mapping(address => uint256) rolls;
        uint256 vaultSnapshot;
    }

    struct RollingDice {
        uint256 requestId;
        address fortuneSeeker;
        uint256 multiplyStake;
        uint256 seizureIndex;
        RollAction action;
    }

    enum RollAction {
        Add,
        Multiply,
        Seizure
    }

    // Chainlink VRF
    VRFCoordinatorV2Interface COORDINATOR;
    bytes32 private KEY_HASH;
    uint64 private SUBSCRIPTION_ID;

    // sAVAX
    IStakedAvax public STAKED_AVAX;

    uint256 public gameStart;
    uint256 public gameEnd;
    uint256 public vaultBalance;
    uint256 public totalFortune;
    uint256 public totalDeposited;
    uint256 public seizureIndex;

    uint256 public diceRollGenerationRate;
    uint256 public additionMultiplier;
    uint256 public multiplicationMultiplier;
    uint256 public minimumFortuneToRollSeize;

    mapping(uint256 => Seizure) public seizures;
    mapping(address => FortuneSeeker) public fortuneSeekers;
    mapping(uint256 => RollingDice) public rollingDie;

    /* -------------------------------------------------------------------------- */
    /*                                 Constructor                                */
    /* -------------------------------------------------------------------------- */

    constructor(
        address _owner,
        address _vrfCoordinator,
        address payable _stakedAvax,
        uint256 _gameStart,
        uint256 _gameEnd,
        uint256 _diceRollGenerationRate,
        uint256 _additionMultiplier,
        uint256 _multiplicationMultiplier,
        uint256 _minimumFortuneToRollSeize,
        bytes32 keyHash,
        uint64 subscriptionId
    ) VRFConsumerBaseV2(_vrfCoordinator) Owned(_owner) {
        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);
        KEY_HASH = keyHash;
        SUBSCRIPTION_ID = subscriptionId;

        STAKED_AVAX = IStakedAvax(_stakedAvax);

        gameStart = _gameStart;
        gameEnd = _gameEnd;
        diceRollGenerationRate = _diceRollGenerationRate;
        additionMultiplier = _additionMultiplier;
        multiplicationMultiplier = _multiplicationMultiplier;
        minimumFortuneToRollSeize = _minimumFortuneToRollSeize;
    }

    /* -------------------------------------------------------------------------- */
    /*                              Public Functions                              */
    /* -------------------------------------------------------------------------- */

    function deposit() public payable {
        require(msg.value > 0, "Must deposit more than 0");

        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        fortuneSeeker.deposit += msg.value;
        totalDeposited += msg.value;

        STAKED_AVAX.submit{value: msg.value}();
    }

    function forfeit() external {
        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        require(fortuneSeeker.deposit > 0, "Must have a deposit");
        require(
            block.timestamp >= gameStart && block.timestamp <= gameEnd,
            "Must be during game"
        );

        uint256 deposited = fortuneSeeker.deposit;
        uint256 fortune = getTotalFortuneFor(msg.sender, fortuneSeeker);

        vaultBalance += fortune;
        totalFortune -= fortune;
        totalDeposited -= deposited;

        delete fortuneSeekers[msg.sender];

        uint256 amount = STAKED_AVAX.getSharesByPooledAvax(deposited);

        require(
            amount < STAKED_AVAX.balanceOf(address(this)),
            "Not enough shares to withdraw"
        );

        STAKED_AVAX.transfer(msg.sender, amount);
    }

    function redeem() external {
        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        require(fortuneSeeker.deposit > 0, "Must have deposited");
        require(block.timestamp >= gameEnd, "Must be after game has ended");

        uint256 reward = calculateRewardFor(msg.sender, fortuneSeeker) +
            STAKED_AVAX.getSharesByPooledAvax(fortuneSeeker.deposit);

        totalDeposited -= fortuneSeeker.deposit;
        totalFortune -= fortuneSeeker.fortune;

        delete fortuneSeekers[msg.sender];

        require(
            reward < STAKED_AVAX.balanceOf(address(this)),
            "Not enough shares to withdraw"
        );

        STAKED_AVAX.transfer(msg.sender, reward);
    }

    function rollAdd() external returns (uint256) {
        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        uint256 requestId = rollDice(fortuneSeeker);

        rollingDie[requestId] = RollingDice({
            requestId: requestId,
            fortuneSeeker: msg.sender,
            action: RollAction.Add,
            multiplyStake: 0,
            seizureIndex: 0
        });

        return requestId;
    }

    function rollMultiply(uint256 stake) external returns (uint256) {
        uint256 stakeModulus = (stake % DICE_SIDES) + 1;

        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        uint256 requestId = rollDice(fortuneSeeker);

        rollingDie[requestId] = RollingDice({
            requestId: requestId,
            fortuneSeeker: msg.sender,
            action: RollAction.Multiply,
            multiplyStake: stakeModulus,
            seizureIndex: 0
        });

        return requestId;
    }

    function rollSeizure() external returns (uint256) {
        Seizure storage seizure = seizures[seizureIndex];
        require(
            block.timestamp >= seizure.start && block.timestamp <= seizure.end,
            "Must be during open seizure"
        );

        FortuneSeeker storage fortuneSeeker = fortuneSeekers[msg.sender];

        require(
            fortuneSeeker.fortune >= minimumFortuneToRollSeize,
            "Must have enough fortune to roll seizure"
        );

        uint256 fee = (fortuneSeeker.fortune * seizure.fee) / PRECISION;

        fortuneSeeker.fortune -= fee;
        totalFortune -= fee;
        vaultBalance += fee;

        uint256 requestId = rollDice(fortuneSeeker);

        rollingDie[requestId] = RollingDice({
            requestId: requestId,
            fortuneSeeker: msg.sender,
            action: RollAction.Seizure,
            multiplyStake: 0,
            seizureIndex: seizureIndex
        });

        return requestId;
    }

    function closeCurrentSeizure() external {
        Seizure storage seizure = seizures[seizureIndex];

        require(seizure.start > 0, "Must have started seizure");
        require(block.timestamp > seizure.end, "Must be after seizure end");

        uint totalRewards = 0;

        for (uint256 i = 0; i < DICE_SIDES; i++) {
            totalRewards +=
                (seizure.rewardShares[i] * vaultBalance) /
                PRECISION;
        }

        seizure.vaultSnapshot = totalRewards;
        vaultBalance -= totalRewards;
        totalFortune += totalRewards;
        seizureIndex += 1;
    }

    /* -------------------------------------------------------------------------- */
    /*                               Admin Functions                              */
    /* -------------------------------------------------------------------------- */

    function setSeizure(
        uint256 index,
        uint256 start,
        uint256 end,
        uint256 fee,
        uint256[DICE_SIDES] calldata rewardShares
    ) external onlyOwner {
        require(start > 0, "Must have start time");

        Seizure storage seizure = seizures[index];

        require(seizure.start == 0, "Seizure already exists");
        require(end > start, "Must have end time");
        require(fee > 0, "Must have fee");
        require(rewardShares.length == DICE_SIDES, "Must have rewards");

        seizure.start = start;
        seizure.end = end;
        seizure.fee = fee;
        seizure.rewardShares = rewardShares;

        for (uint256 i = 0; i < DICE_SIDES; i++) {
            seizure.rewardSharesTotal += rewardShares[i];
        }
    }

    function calculateSeizureRewards(
        address fortuneSeeker
    ) public view returns (uint256) {
        uint256 seizureRewards = 0;

        for (uint256 i = 0; i < seizureIndex; i++) {
            Seizure storage seizure = seizures[i];

            uint256 roll = seizure.rolls[fortuneSeeker];

            if (roll == 0) {
                continue;
            }

            uint256 rollRewardShare = seizure.rewardShares[roll - 1];

            uint256 rollReward = (rollRewardShare * seizure.vaultSnapshot) /
                seizure.rewardSharesTotal;
						
						seizureRewards += rollReward / seizure.seizorTallies[roll - 1];
        }

        return seizureRewards;
    }

    /* -------------------------------------------------------------------------- */
    /*                             Internal Functions                             */
    /* -------------------------------------------------------------------------- */

    function getTotalFortuneFor(
        address seekerAddress,
        FortuneSeeker storage fortuneSeeker
    ) internal view returns (uint256) {
        return fortuneSeeker.fortune + calculateSeizureRewards(seekerAddress);
    }

    function calculateDiceRolls(
        FortuneSeeker storage fortuneSeeker
    ) internal view returns (uint256) {
        uint256 timeSinceLastDiceRoll = block.timestamp -
            fortuneSeeker.lastDiceRollTimestamp;
        uint256 diceRollsRemaining = fortuneSeeker.diceRollsRemaining +
            (timeSinceLastDiceRoll * diceRollGenerationRate);

        return diceRollsRemaining;
    }

    function calculateRewardFor(
        address seekerAddress,
        FortuneSeeker storage fortuneSeeker
    ) internal view returns (uint256) {
        uint256 totalRewards = STAKED_AVAX.balanceOf(address(this)) -
            STAKED_AVAX.getSharesByPooledAvax(totalDeposited);

        uint256 seekerFortune = getTotalFortuneFor(
            seekerAddress,
            fortuneSeeker
        );

        return (totalRewards * seekerFortune) / totalFortune;
    }

    function rollDice(
        FortuneSeeker storage fortuneSeeker
    ) internal returns (uint256) {
        require(fortuneSeeker.deposit > 0, "Must have a deposit");
        require(
            block.timestamp >= gameStart && block.timestamp <= gameEnd,
            "Must be during game"
        );

        uint256 diceRollsRemaining = calculateDiceRolls(fortuneSeeker);

        require(
            diceRollsRemaining >= 1 * PRECISION,
            "Must have dice rolls remaining"
        );

        fortuneSeeker.diceRollsRemaining = diceRollsRemaining - (1 * PRECISION);
        fortuneSeeker.lastDiceRollTimestamp = block.timestamp;

        uint256 requestId = COORDINATOR.requestRandomWords(
            KEY_HASH,
            SUBSCRIPTION_ID,
            3,
            100_000,
            1
        );

        return requestId;
    }

    function finalizeAddRoll(
        uint256 diceRoll,
        FortuneSeeker storage fortuneSeeker
    ) internal {
        uint256 fortuneRewards = (diceRoll * additionMultiplier) / PRECISION;
        fortuneSeeker.fortune += fortuneRewards;
        totalFortune += fortuneRewards;
    }

    function finalizeMultiplyRoll(
        uint256 diceRoll,
        FortuneSeeker storage fortuneSeeker,
        uint256 stake
    ) internal {
        bool isWin = diceRoll >= stake;

        uint256 fortuneRewards = (fortuneSeeker.fortune *
            stake *
            multiplicationMultiplier) /
            DICE_SIDES /
            PRECISION;

        if (isWin) {
            fortuneSeeker.fortune += fortuneRewards;
            totalFortune += fortuneRewards;
        } else {
            fortuneSeeker.fortune -= fortuneRewards;
            totalFortune -= fortuneRewards;
            vaultBalance += fortuneRewards;
        }
    }

    function finalizeSeizureRoll(
        uint256 diceRoll,
        RollingDice storage rollingDice
    ) internal {
        uint256 prevRoll = seizures[rollingDice.seizureIndex].rolls[
            rollingDice.fortuneSeeker
        ];

        if (prevRoll > 0) {
            seizures[rollingDice.seizureIndex].seizorTallies[prevRoll - 1] -= 1;
        }

        seizures[rollingDice.seizureIndex].seizorTallies[diceRoll - 1] += 1;

        seizures[rollingDice.seizureIndex].rolls[
            rollingDice.fortuneSeeker
        ] = diceRoll;
    }

    function fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) internal override {
        RollingDice storage rollingDice = rollingDie[requestId];
        FortuneSeeker storage fortuneSeeker = fortuneSeekers[
            rollingDice.fortuneSeeker
        ];

        uint256 diceRoll = (randomWords[0] % DICE_SIDES) + 1;

        if (rollingDice.action == RollAction.Add) {
            finalizeAddRoll(diceRoll, fortuneSeeker);
        } else if (rollingDice.action == RollAction.Multiply) {
            finalizeMultiplyRoll(
                diceRoll,
                fortuneSeeker,
                rollingDice.multiplyStake
            );
        } else if (rollingDice.action == RollAction.Seizure) {
            finalizeSeizureRoll(diceRoll, rollingDice);
        } else {
						revert("Invalid roll action");
				}

        delete rollingDie[requestId];
    }

    receive() external payable {
        deposit();
    }
}
